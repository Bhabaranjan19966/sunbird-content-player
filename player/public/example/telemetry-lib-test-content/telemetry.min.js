function isEmpty(obj) {
    if (null == obj) return !0;
    if (obj.length > 0) return !1;
    if (0 === obj.length) return !0;
    if ("object" != typeof obj) return !0;
    for (var key in obj) if (hasOwnProperty.call(obj, key)) return !1;
    return !0;
}

function findWhere(list, obj) {
    return list.find(function(e) {
        return e[Object.keys(obj)[0]] == Object.values(obj)[0];
    });
}

!function() {
    var initializing = !1, fnTest = /xyz/.test(function() {
        xyz;
    }) ? /\b_super\b/ : /.*/;
    this.Class = function() {}, Class.extend = function(prop) {
        function Class() {
            !initializing && this.init && this.init.apply(this, arguments);
        }
        var _super = this.prototype;
        initializing = !0;
        var prototype = new this();
        initializing = !1;
        for (var name in prop) prototype[name] = "function" == typeof prop[name] && "function" == typeof _super[name] && fnTest.test(prop[name]) ? function(name, fn) {
            return function() {
                var tmp = this._super;
                this._super = _super[name];
                var ret = fn.apply(this, arguments);
                return this._super = tmp, ret;
            };
        }(name, prop[name]) : prop[name];
        return Class.prototype = prototype, Class.prototype.constructor = Class, Class.extend = arguments.callee, 
        Class;
    };
}();

var detectClient = function() {
    var verOffset, ix, nAgt = navigator.userAgent, browserName = navigator.appName, fullVersion = "" + parseFloat(navigator.appVersion);
    return -1 != (verOffset = nAgt.indexOf("Opera")) ? (browserName = "opera", fullVersion = nAgt.substring(verOffset + 6), 
    -1 != (verOffset = nAgt.indexOf("Version")) && (fullVersion = nAgt.substring(verOffset + 8))) : -1 != (verOffset = nAgt.indexOf("MSIE")) ? (browserName = "IE", 
    fullVersion = nAgt.substring(verOffset + 5)) : -1 != (verOffset = nAgt.indexOf("Chrome")) ? (browserName = "chrome", 
    fullVersion = nAgt.substring(verOffset + 7)) : -1 != (verOffset = nAgt.indexOf("Safari")) ? (browserName = "safari", 
    fullVersion = nAgt.substring(verOffset + 7), -1 != (verOffset = nAgt.indexOf("Version")) && (fullVersion = nAgt.substring(verOffset + 8))) : -1 != (verOffset = nAgt.indexOf("Firefox")) && (browserName = "firefox", 
    fullVersion = nAgt.substring(verOffset + 8)), -1 != (ix = fullVersion.indexOf(";")) && (fullVersion = fullVersion.substring(0, ix)), 
    -1 != (ix = fullVersion.indexOf(" ")) && (fullVersion = fullVersion.substring(0, ix)), 
    {
        browser: browserName,
        browserver: fullVersion,
        os: navigator.platform
    };
}, CryptoJS = CryptoJS || function(s, p) {
    var m = {}, l = m.lib = {}, n = function() {}, r = l.Base = {
        extend: function(b) {
            n.prototype = this;
            var h = new n();
            return b && h.mixIn(b), h.hasOwnProperty("init") || (h.init = function() {
                h.$super.init.apply(this, arguments);
            }), h.init.prototype = h, h.$super = this, h;
        },
        create: function() {
            var b = this.extend();
            return b.init.apply(b, arguments), b;
        },
        init: function() {},
        mixIn: function(b) {
            for (var h in b) b.hasOwnProperty(h) && (this[h] = b[h]);
            b.hasOwnProperty("toString") && (this.toString = b.toString);
        },
        clone: function() {
            return this.init.prototype.extend(this);
        }
    }, q = l.WordArray = r.extend({
        init: function(b, h) {
            b = this.words = b || [], this.sigBytes = h != p ? h : 4 * b.length;
        },
        toString: function(b) {
            return (b || t).stringify(this);
        },
        concat: function(b) {
            var h = this.words, a = b.words, j = this.sigBytes;
            if (b = b.sigBytes, this.clamp(), j % 4) for (var g = 0; b > g; g++) h[j + g >>> 2] |= (a[g >>> 2] >>> 24 - 8 * (g % 4) & 255) << 24 - 8 * ((j + g) % 4); else if (65535 < a.length) for (g = 0; b > g; g += 4) h[j + g >>> 2] = a[g >>> 2]; else h.push.apply(h, a);
            return this.sigBytes += b, this;
        },
        clamp: function() {
            var b = this.words, h = this.sigBytes;
            b[h >>> 2] &= 4294967295 << 32 - 8 * (h % 4), b.length = s.ceil(h / 4);
        },
        clone: function() {
            var b = r.clone.call(this);
            return b.words = this.words.slice(0), b;
        },
        random: function(b) {
            for (var h = [], a = 0; b > a; a += 4) h.push(4294967296 * s.random() | 0);
            return new q.init(h, b);
        }
    }), v = m.enc = {}, t = v.Hex = {
        stringify: function(b) {
            var a = b.words;
            b = b.sigBytes;
            for (var g = [], j = 0; b > j; j++) {
                var k = a[j >>> 2] >>> 24 - 8 * (j % 4) & 255;
                g.push((k >>> 4).toString(16)), g.push((15 & k).toString(16));
            }
            return g.join("");
        },
        parse: function(b) {
            for (var a = b.length, g = [], j = 0; a > j; j += 2) g[j >>> 3] |= parseInt(b.substr(j, 2), 16) << 24 - 4 * (j % 8);
            return new q.init(g, a / 2);
        }
    }, a = v.Latin1 = {
        stringify: function(b) {
            var a = b.words;
            b = b.sigBytes;
            for (var g = [], j = 0; b > j; j++) g.push(String.fromCharCode(a[j >>> 2] >>> 24 - 8 * (j % 4) & 255));
            return g.join("");
        },
        parse: function(b) {
            for (var a = b.length, g = [], j = 0; a > j; j++) g[j >>> 2] |= (255 & b.charCodeAt(j)) << 24 - 8 * (j % 4);
            return new q.init(g, a);
        }
    }, u = v.Utf8 = {
        stringify: function(b) {
            try {
                return decodeURIComponent(escape(a.stringify(b)));
            } catch (g) {
                throw Error("Malformed UTF-8 data");
            }
        },
        parse: function(b) {
            return a.parse(unescape(encodeURIComponent(b)));
        }
    }, g = l.BufferedBlockAlgorithm = r.extend({
        reset: function() {
            this._data = new q.init(), this._nDataBytes = 0;
        },
        _append: function(b) {
            "string" == typeof b && (b = u.parse(b)), this._data.concat(b), this._nDataBytes += b.sigBytes;
        },
        _process: function(b) {
            var a = this._data, g = a.words, j = a.sigBytes, k = this.blockSize, m = j / (4 * k), m = b ? s.ceil(m) : s.max((0 | m) - this._minBufferSize, 0);
            if (b = m * k, j = s.min(4 * b, j), b) {
                for (var l = 0; b > l; l += k) this._doProcessBlock(g, l);
                l = g.splice(0, b), a.sigBytes -= j;
            }
            return new q.init(l, j);
        },
        clone: function() {
            var b = r.clone.call(this);
            return b._data = this._data.clone(), b;
        },
        _minBufferSize: 0
    });
    l.Hasher = g.extend({
        cfg: r.extend(),
        init: function(b) {
            this.cfg = this.cfg.extend(b), this.reset();
        },
        reset: function() {
            g.reset.call(this), this._doReset();
        },
        update: function(b) {
            return this._append(b), this._process(), this;
        },
        finalize: function(b) {
            return b && this._append(b), this._doFinalize();
        },
        blockSize: 16,
        _createHelper: function(b) {
            return function(a, g) {
                return new b.init(g).finalize(a);
            };
        },
        _createHmacHelper: function(b) {
            return function(a, g) {
                return new k.HMAC.init(b, g).finalize(a);
            };
        }
    });
    var k = m.algo = {};
    return m;
}(Math);

!function(s) {
    function p(a, k, b, h, l, j, m) {
        return a = a + (k & b | ~k & h) + l + m, (a << j | a >>> 32 - j) + k;
    }
    function m(a, k, b, h, l, j, m) {
        return a = a + (k & h | b & ~h) + l + m, (a << j | a >>> 32 - j) + k;
    }
    function l(a, k, b, h, l, j, m) {
        return a = a + (k ^ b ^ h) + l + m, (a << j | a >>> 32 - j) + k;
    }
    function n(a, k, b, h, l, j, m) {
        return a = a + (b ^ (k | ~h)) + l + m, (a << j | a >>> 32 - j) + k;
    }
    for (var r = CryptoJS, q = r.lib, v = q.WordArray, t = q.Hasher, q = r.algo, a = [], u = 0; 64 > u; u++) a[u] = 4294967296 * s.abs(s.sin(u + 1)) | 0;
    q = q.MD5 = t.extend({
        _doReset: function() {
            this._hash = new v.init([ 1732584193, 4023233417, 2562383102, 271733878 ]);
        },
        _doProcessBlock: function(g, k) {
            for (var b = 0; 16 > b; b++) {
                var h = k + b, w = g[h];
                g[h] = 16711935 & (w << 8 | w >>> 24) | 4278255360 & (w << 24 | w >>> 8);
            }
            var b = this._hash.words, h = g[k + 0], w = g[k + 1], j = g[k + 2], q = g[k + 3], r = g[k + 4], s = g[k + 5], t = g[k + 6], u = g[k + 7], v = g[k + 8], x = g[k + 9], y = g[k + 10], z = g[k + 11], A = g[k + 12], B = g[k + 13], C = g[k + 14], D = g[k + 15], c = b[0], d = b[1], e = b[2], f = b[3], c = p(c, d, e, f, h, 7, a[0]), f = p(f, c, d, e, w, 12, a[1]), e = p(e, f, c, d, j, 17, a[2]), d = p(d, e, f, c, q, 22, a[3]), c = p(c, d, e, f, r, 7, a[4]), f = p(f, c, d, e, s, 12, a[5]), e = p(e, f, c, d, t, 17, a[6]), d = p(d, e, f, c, u, 22, a[7]), c = p(c, d, e, f, v, 7, a[8]), f = p(f, c, d, e, x, 12, a[9]), e = p(e, f, c, d, y, 17, a[10]), d = p(d, e, f, c, z, 22, a[11]), c = p(c, d, e, f, A, 7, a[12]), f = p(f, c, d, e, B, 12, a[13]), e = p(e, f, c, d, C, 17, a[14]), d = p(d, e, f, c, D, 22, a[15]), c = m(c, d, e, f, w, 5, a[16]), f = m(f, c, d, e, t, 9, a[17]), e = m(e, f, c, d, z, 14, a[18]), d = m(d, e, f, c, h, 20, a[19]), c = m(c, d, e, f, s, 5, a[20]), f = m(f, c, d, e, y, 9, a[21]), e = m(e, f, c, d, D, 14, a[22]), d = m(d, e, f, c, r, 20, a[23]), c = m(c, d, e, f, x, 5, a[24]), f = m(f, c, d, e, C, 9, a[25]), e = m(e, f, c, d, q, 14, a[26]), d = m(d, e, f, c, v, 20, a[27]), c = m(c, d, e, f, B, 5, a[28]), f = m(f, c, d, e, j, 9, a[29]), e = m(e, f, c, d, u, 14, a[30]), d = m(d, e, f, c, A, 20, a[31]), c = l(c, d, e, f, s, 4, a[32]), f = l(f, c, d, e, v, 11, a[33]), e = l(e, f, c, d, z, 16, a[34]), d = l(d, e, f, c, C, 23, a[35]), c = l(c, d, e, f, w, 4, a[36]), f = l(f, c, d, e, r, 11, a[37]), e = l(e, f, c, d, u, 16, a[38]), d = l(d, e, f, c, y, 23, a[39]), c = l(c, d, e, f, B, 4, a[40]), f = l(f, c, d, e, h, 11, a[41]), e = l(e, f, c, d, q, 16, a[42]), d = l(d, e, f, c, t, 23, a[43]), c = l(c, d, e, f, x, 4, a[44]), f = l(f, c, d, e, A, 11, a[45]), e = l(e, f, c, d, D, 16, a[46]), d = l(d, e, f, c, j, 23, a[47]), c = n(c, d, e, f, h, 6, a[48]), f = n(f, c, d, e, u, 10, a[49]), e = n(e, f, c, d, C, 15, a[50]), d = n(d, e, f, c, s, 21, a[51]), c = n(c, d, e, f, A, 6, a[52]), f = n(f, c, d, e, q, 10, a[53]), e = n(e, f, c, d, y, 15, a[54]), d = n(d, e, f, c, w, 21, a[55]), c = n(c, d, e, f, v, 6, a[56]), f = n(f, c, d, e, D, 10, a[57]), e = n(e, f, c, d, t, 15, a[58]), d = n(d, e, f, c, B, 21, a[59]), c = n(c, d, e, f, r, 6, a[60]), f = n(f, c, d, e, z, 10, a[61]), e = n(e, f, c, d, j, 15, a[62]), d = n(d, e, f, c, x, 21, a[63]);
            b[0] = b[0] + c | 0, b[1] = b[1] + d | 0, b[2] = b[2] + e | 0, b[3] = b[3] + f | 0;
        },
        _doFinalize: function() {
            var a = this._data, k = a.words, b = 8 * this._nDataBytes, h = 8 * a.sigBytes;
            k[h >>> 5] |= 128 << 24 - h % 32;
            var l = s.floor(b / 4294967296);
            for (k[(h + 64 >>> 9 << 4) + 15] = 16711935 & (l << 8 | l >>> 24) | 4278255360 & (l << 24 | l >>> 8), 
            k[(h + 64 >>> 9 << 4) + 14] = 16711935 & (b << 8 | b >>> 24) | 4278255360 & (b << 24 | b >>> 8), 
            a.sigBytes = 4 * (k.length + 1), this._process(), a = this._hash, k = a.words, b = 0; 4 > b; b++) h = k[b], 
            k[b] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8);
            return a;
        },
        clone: function() {
            var a = t.clone.call(this);
            return a._hash = this._hash.clone(), a;
        }
    }), r.MD5 = t._createHelper(q), r.HmacMD5 = t._createHmacHelper(q);
}(Math), InActiveEvent = Class.extend({
    init: function() {},
    ext: function() {
        return this;
    },
    flush: function() {},
    __noSuchMethod__: function() {
        return console.log("TelemetryService is inActive"), this;
    }
}), TelemetryEvent = Class.extend({
    createdTime: void 0,
    _isStarted: !1,
    startTime: 0,
    name: void 0,
    event: void 0,
    init: function(eid, version, body, user, gdata, cdata, otherData) {
        if (this.createdTime = getCurrentTime(), this.name = eid, this.event = {
            ver: version,
            uid: user.uid,
            sid: otherData ? otherData.sid || "" : "",
            did: otherData ? otherData.did || "" : "",
            edata: {
                eks: body || {}
            },
            eid: eid,
            gdata: gdata,
            cdata: cdata
        }, otherData) for (var otherKeys = Object.keys(otherData), i = 0; i < otherKeys.length; i++) {
            var keyName = otherKeys[i], sourceObj = this.event[keyName], targetObj = otherData[keyName];
            "undefined" != typeof sourceObj ? "object" == typeof sourceObj ? Array.isArray(sourceObj) ? sourceObj.push(targetObj) : Object.assign(sourceObj, targetObj) : sourceObj = targetObj : "undefined" != typeof targetObj && (this.event[keyName] = targetObj);
        }
        this.event.ets = getCurrentTime(this.createdTime);
    },
    flush: function(apiName) {
        if (this.event) {
            var eve = new CustomEvent("telemetryEvent", {
                detail: this.event
            });
            document.dispatchEvent(eve), console.log(JSON.stringify(this.event));
        }
    },
    ext: function(ext) {
        if ("object" == typeof ext) if (this.event.edata.ext) for (key in ext) this.event.edata.ext[key] = ext[key]; else this.event.edata.ext = ext;
        return this;
    },
    start: function() {
        return this._isStarted = !0, this.startTime = getCurrentTime(), this;
    },
    end: function(data) {
        if (this._isStarted) {
            var eks = {};
            return "undefined" != typeof data && "undefined" != typeof data.progress && (eks.progress = data.progress), 
            "undefined" != typeof data && "undefined" != typeof data.stageid && (eks.stageid = data.stageid), 
            this.event.edata.eks.length = Math.round((getCurrentTime() - this.startTime) / 1e3), 
            this.event.edata.eks.progress = eks.progress || void 0, this.event.edata.eks.stageid = eks.stageid || void 0, 
            this.event.ets = getCurrentTime(), this._isStarted = !1, this;
        }
        throw "can't end event without starting.";
    }
}), TelemetryV2Manager = Class.extend({
    _end: new Array(),
    _start: new Array(),
    init: function() {
        console.info("TelemetryService Version 2 initialized..");
    },
    exitWithError: function(error) {
        var message = "";
        error && (message += " Error: " + JSON.stringify(error)), TelemetryServiceV2.exitApp();
    },
    createEvent: function(eventName, body) {
        return new TelemetryEvent(eventName, Telemetry._version, body, Telemetry.user, Telemetry._gameData, Telemetry.config.cdata, Telemetry._otherData);
    },
    start: function(config, contentId, contentVer, type, data) {
        return this._end.push(this.createEvent("OE_END", {}).start()), this._start.push({
            contentId: contentId,
            contentVer: contentVer
        }), this.createEvent("OE_START", data);
    },
    end: function(data) {
        return this.telemetryStartActive() ? (this._start.pop(), void 0 == data.progress && (data.progress = 50), 
        Telemetry.isActive = !1, Telemetry.instance = void 0, this._end.pop().end(data)) : void console.warn("Telemetry service end is already logged Please log start telemetry again");
    },
    interact: function(data) {
        if (void 0 != data.type && void 0 != data.id) {
            if (data.extra.optionTag && this.itemResponse(data.extra), "DRAG" != data.type) {
                var eks = {
                    stageid: data.extra.stageId ? data.extra.stageId.toString() : "",
                    type: data.type,
                    subtype: data.extra.subtype ? data.extra.subtype : "",
                    pos: data.extra.pos ? data.extra.pos : [],
                    id: data.id,
                    tid: data.extra.tid ? data.extra.tid : "",
                    uri: data.extra.uri ? data.extra.uri : "",
                    extype: "",
                    values: data.extra.values ? data.extra.values : []
                }, eventName = "OE_INTERACT";
                return this.createEvent(eventName, eks);
            }
        } else console.info("Required fields missing for Telemetry interact ");
    },
    assess: function(qid, subj, qlevel, data) {
        if (void 0 != qid && void 0 != subj && void 0 != qlevel) {
            var maxscore;
            if (subj = subj ? subj : "", data && (maxscore = data.maxscore || 1), qlevel = qlevel ? qlevel : "MEDIUM", 
            qid) {
                var eks = {
                    qid: qid,
                    maxscore: maxscore,
                    params: []
                };
                return this.createEvent("OE_ASSESS", eks).start();
            }
            return console.error("qid is required to create assess event.", qid), new InActiveEvent();
        }
        console.info("Required fields missing for Telemetry assess ");
    },
    error: function(data) {
        if (void 0 != data.err && void 0 != data.errtype && void 0 != data.stacktrace) {
            var data = {
                env: data.env || "",
                type: data.errtype,
                stacktrace: data.stacktrace,
                stageid: data.stageId || "",
                objecttype: data.objectType || "",
                objectid: data.objectId || "",
                err: data.err,
                action: data.action || "",
                data: data.data || "",
                severity: data.severity || ""
            };
            return this.createEvent("OE_ERROR", data);
        }
        console.info("Required fields missing for Telemetry error ");
    },
    assessEnd: function(eventObj, data) {
        return void 0 != eventObj && void 0 != data ? (eventObj._isStarted || (eventObj._isStarted = !0), 
        eventObj.event.edata.eks.score = data.score || 0, eventObj.event.edata.eks.pass = data.pass ? "Yes" : "No", 
        eventObj.event.edata.eks.resvalues = isEmpty(data.res) ? [] : data.res, eventObj.event.edata.eks.uri = data.uri || "", 
        eventObj.event.edata.eks.qindex = data.qindex || 0, eventObj.event.edata.eks.exlength = 0, 
        eventObj.event.edata.eks.qtitle = data.qtitle, eventObj.event.edata.eks.qdesc = data.qdesc.substr(0, 140), 
        eventObj.event.edata.eks.mmc = data.mmc, eventObj.event.edata.eks.mc = data.mc, 
        Array.isArray(eventObj.event.edata.eks.resvalues) ? eventObj.event.edata.eks.resvalues = eventObj.event.edata.eks.resvalues.map(function(val) {
            return val = "object" == typeof val ? val : {
                "0": val
            };
        }) : eventObj.event.edata.eks.resvalues = [], eventObj.end(), eventObj) : void console.info("Required fields missing for Telemetry assessEnd ");
    },
    interrupt: function(data) {
        if (data.type) {
            var eks = {
                type: data.type,
                stageid: data.pageid || ""
            }, eventName = data.eventid ? data.eventid : "OE_INTERRUPT";
            return this.createEvent(eventName, eks);
        }
        console.info("Required fields missing for Telemetry interrupt ");
    },
    exitApp: function() {
        setTimeout(function() {
            navigator.app.exitApp();
        }, 5e3);
    },
    navigate: function(pageid, type, subtype, data) {
        if (void 0 != pageid && void 0 != type) {
            var eks = {
                stageid: pageid ? pageid : "",
                stageto: data && data.stageto ? data.stageto : "",
                type: type ? type : "",
                subtype: subtype ? subtype : "",
                itype: ""
            };
            return this.createEvent("OE_NAVIGATE", eks);
        }
        console.info("Required fields missing for Telemetry navigate ");
    },
    itemResponse: function(data) {
        if (void 0 != data.qid && void 0 != data.type && void 0 != data.target && void 0 != data.values) {
            var eks = ("MCQ" == data.optionTag ? "CHOOSE" : "MATCH", {
                target: data.target,
                qid: data.qid,
                type: data.type,
                state: data.state,
                resvalues: isEmpty(data.values) ? [] : data.values
            });
            return Telemetry.flushEvent(this.createEvent("OE_ITEM_RESPONSE", eks));
        }
        console.info("Required fields missing for Telemetry itemResponse ");
    },
    sendFeedback: function(eks) {
        return this.createEvent("", eks);
    },
    telemetryStartActive: function() {
        return !isEmpty(this._start);
    },
    xapi: function(type, data) {
        var eks = {
            xapi: data
        };
        return this.createEvent("OE_XAPI", eks);
    }
}), function() {
    return this.Telemetry = function() {}, this.isActive = !1, Telemetry.config = void 0, 
    this._defaultValue = {
        pdataId: "genie",
        pdataVer: "6.5.2567",
        pdataPid: "",
        channel: "in.ekstep",
        uid: "anonymous",
        did: "",
        authtoken: "",
        sid: "",
        batchsize: 20,
        mode: "play",
        host: "https://api.ekstep.in",
        endpoint: "/data/v3/telemetry",
        tags: [],
        cdata: [],
        apislug: "/action"
    }, this.setConfig = function(config, contentId, contentVer) {
        config = {
            pdata: {
                id: config && config.pdata ? config.pdata.id : this._defaultValue.pdataId,
                ver: config && config.pdata ? config.pdata.ver : this._defaultValue.pdataVer,
                pid: config && config.pdata ? config.pdata.pid : this._defaultValue.pdataPid
            },
            channel: config && config.channel ? config.channel : this._defaultValue.channel,
            uid: config && config.uid ? config.uid : this._defaultValue.uid,
            did: config && config.did ? config.did : this._defaultValue.did,
            authtoken: config && config.authtoken ? config.authtoken : this._defaultValue.authtoken,
            sid: config && config.sid ? config.sid : this._defaultValue.sid,
            batchsize: config && config.batchsize ? config.batchsize : this._defaultValue.batchsize,
            mode: config && config.mode ? config.mode : this._defaultValue.mode,
            host: config && config.host ? config.host : this._defaultValue.host,
            endpoint: config && config.endpoint ? config.endpoint : this._defaultValue.endpoint,
            tags: config && config.tags ? config.tags : this._defaultValue.tags,
            cdata: config && config.cdata ? config.cdata : this._defaultValue.cdata,
            apislug: config && config.apislug ? config.apislug : this._defaultValue.apislug
        }, this.isActive = !0, Telemetry.config = config, console.log("Telemetry config ", Telemetry.config);
    }, Telemetry.start = function(config, contentId, contentVer, type, data) {
        setConfig(config, contentId, contentVer);
    }, Telemetry;
}();

var TelemetrySyncManager = {
    _teleData: [],
    _maxTeleInstance: 10,
    _requiredFields: {},
    updateConfig: function() {
        var did = detectClient();
        this._requiredFields = {}, this._requiredFields.uid = Telemetry.config.uid, this._requiredFields.sid = Telemetry.config.sid, 
        this._requiredFields.did = Telemetry.config.did || did, TelemetrySyncManager._maxTeleInstance = Telemetry.config.batchsize || TelemetrySyncManager._maxTeleInstance, 
        TelemetrySyncManager._maxTeleInstance = TelemetrySyncManager._maxTeleInstance < 10 ? 10 : TelemetrySyncManager._maxTeleInstance > 1e3 ? 1e3 : TelemetrySyncManager._maxTeleInstance;
    },
    initialize: function() {
        var instance = this;
        document.addEventListener("telemetryEvent", function(data) {
            data = data.detail, data = instance.appendRequiredFields(data), instance.addToQueue(data);
        });
    },
    appendRequiredFields: function(data) {
        return jQuery.extend(data, this._requiredFields), data.mid = "OE_" + CryptoJS.MD5(JSON.stringify(data)).toString(), 
        data;
    },
    sendTelemetry: function(telemetryData) {
        var currentTimeStamp = getCurrentTime(), telemetryObj = {
            id: "ekstep.telemetry",
            ver: Telemetry._version,
            ets: currentTimeStamp,
            events: telemetryData
        }, headers = {};
        "undefined" != typeof Telemetry.config.authtoken && (headers.Authorization = "Bearer " + Telemetry.config.authtoken), 
        this.callApi(telemetryObj, headers, function(data) {
            console.log("Telemetry API success", data);
        });
    },
    addToQueue: function(data) {
        if (this._teleData.push(data), "OE_END" == data.eid.toUpperCase() || this._teleData.length >= this._maxTeleInstance) {
            var telemetryData = jQuery.extend({}, this._teleData);
            this._teleData = [], this.sendTelemetry(telemetryData);
        }
    },
    callApi: function(telemetryObj, headersParam, cb) {
        var fullPath = Telemetry.config.host + Telemetry.config.apislug + Telemetry.config.endpoint;
        headersParam.dataType = "json", headersParam["Content-Type"] = "application/json", 
        jQuery.ajax({
            url: fullPath,
            type: "POST",
            headers: headersParam,
            data: telemetryObj
        }).done(function(resp) {
            cb(resp);
        }).fail(function(error, textStatus, errorThrown) {
            403 == error.status ? console.error("Authentication error " + textStatus) : console.error("Error while sync of Telemetry: " + textStatus);
        });
    }
};

TelemetrySyncManager.initialize();